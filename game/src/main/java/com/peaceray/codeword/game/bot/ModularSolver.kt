package com.peaceray.codeword.game.bot

import com.peaceray.codeword.game.data.Constraint
import com.peaceray.codeword.game.bot.modules.generation.CandidateGenerationModule
import com.peaceray.codeword.game.bot.modules.scoring.CandidateScoringModule
import com.peaceray.codeword.game.bot.modules.selection.CandidateSelectionModule
import com.peaceray.codeword.game.bot.modules.shared.Candidates

/**
 * A Solver that generates guesses using a 3-step algorithm -- generate, score, select --
 * where each step may be performed according to different rules in a modular way.
 *
 * *generate*: provided with a set of constraints (probably representing a snapshot of game
 * guess evaluations), generate a set of *candidates* (guesses that might be provided in the
 * next round) and one of *solutions* (possible underlying truth codes). In most cases candidates
 * will be a superset of solutions, where codes known not to be the solution might still provide
 * useful information if attempted as a guess. Example: as candidates consider all valid codes
 * except those already tried, and as solutions consider all codes not already eliminated by
 * constraints.
 *
 * *score*: assess the strength of each possible candidate numerically, assigning a number to each.
 * Scores are non-negative with no upper bound. Example: consider the score of a candidate as
 * "the minimum number of solutions eliminated across all possible evaluations of this guess"
 *
 * *select*: given the output of previous steps, select one candidate to provide as a guess.
 * Example: select the candidate with the highest score, preferring (in ties) one that is a
 * potential solution.
 */
class ModularSolver(
    private val generator: CandidateGenerationModule,
    private val scorer: CandidateScoringModule,
    private val selector: CandidateSelectionModule
): Solver {

    var candidates = Candidates(listOf(), listOf())
        private set

    var scores = mapOf<String, Double>()
        private set

    var guess: String? = null
        private set

    /**
     * An optional operation that initializes all properties by generating a guess based on
     * no constraints. Depending on module design, this operation may take a while, but should make
     * the on-demand generation of the next guess (possibly) faster; if not you can always read
     * from [guess].
     */
    fun initialize(): ModularSolver {
        generateGuess(listOf())
        return this
    }

    /**
     * Given the provided code constraints, generates a guess.
     *
     * The guess is generated by applying component modules:
     * The [generator] produces a list of candidate guesses and solutions under [constraints]
     * The [scorer] calculates a score for each candidate guess -- higher is better.
     * The [selector] picks a guess based on calculated scores; most trivially, the maximum.
     *
     * The properties [candidates], [scores], and [guess] are set as a side effect of this function.
     */
    override fun generateGuess(constraints: List<Constraint>): String {
        candidates = generator.generateCandidates(constraints)
        scores = scorer.scoreCandidates(candidates)
        guess = selector.selectCandidate(candidates, scores)

        /*
        if (constraints.isEmpty()) {
            println("Top 500 words:")
            candidates.guesses.sortedByDescending { scores[it] ?: 0.0 }
                .take(500)
                .forEach { println(it) }
        }
        */

        return guess!!
    }
}