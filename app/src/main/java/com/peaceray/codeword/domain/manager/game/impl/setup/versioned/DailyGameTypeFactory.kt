package com.peaceray.codeword.domain.manager.game.impl.setup.versioned

import com.peaceray.codeword.data.model.game.GameType
import com.peaceray.codeword.domain.manager.game.impl.setup.versioned.seed.SeedVersion
import com.peaceray.codeword.domain.manager.game.impl.setup.versioned.seed.VersionedBySeed

/**
 * A [GameTypeFactory] specifically for Daily games. An abstract class; concrete implementations
 * should apply versioned game rule logic. This class provides a companion function to select
 * the appropriate [GameTypeFactory] for a given [SeedVersion].
 */
abstract class DailyGameTypeFactory(version: SeedVersion): GameTypeFactory, VersionedBySeed(version) {
    // assume seedDetail is ignored, and GameTypes are generated by randomSeed.
    override fun getSeedDetail(randomSeed: Long, gameType: GameType) = ""
    override fun generateSeedDetail(randomSeed: Long) = ""

    companion object {
        private val cachedFactories: MutableMap<SeedVersion, DailyGameTypeFactory> = mutableMapOf()
        private val defaultFactory = DailyGameTypeFactoryV1()

        fun getFactory(seedVersion: SeedVersion): DailyGameTypeFactory {
            var factory = cachedFactories[seedVersion]

            if (factory == null) {
                factory = when (seedVersion) {
                    SeedVersion.V1 -> DailyGameTypeFactoryV1()
                }
                cachedFactories[seedVersion] = factory
            }

            return factory
        }

        fun getGameType(seedVersion: SeedVersion, randomSeed: Long, seedDetail: String): GameType = getFactory(seedVersion).getGameType(randomSeed, seedDetail)

        fun getSeedDetail(seedVersion: SeedVersion, randomSeed: Long, gameType: GameType): String = getFactory(seedVersion).getSeedDetail(randomSeed, gameType)

        fun generateSeedDetail(seedVersion: SeedVersion, randomSeed: Long): String = getFactory(seedVersion).generateSeedDetail(randomSeed)
    }
}